
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>anet: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/andrei-cloud/anet/broker.go (67.7%)</option>
				
				<option value="file1">github.com/andrei-cloud/anet/bufferpool.go (75.0%)</option>
				
				<option value="file2">github.com/andrei-cloud/anet/example/main.go (0.0%)</option>
				
				<option value="file3">github.com/andrei-cloud/anet/pool.go (61.7%)</option>
				
				<option value="file4">github.com/andrei-cloud/anet/task.go (25.0%)</option>
				
				<option value="file5">github.com/andrei-cloud/anet/utils.go (73.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package anet

import (
        "context"
        "errors"
        "fmt"
        "math/rand"
        "net"
        "sync"
        "sync/atomic"
        "time"

        "golang.org/x/sync/errgroup"
)

var (
        // ErrTimeout indicates a response was not received within the deadline.
        ErrTimeout = errors.New("timeout on response")

        // ErrQuit indicates the broker is shutting down normally.
        ErrQuit = errors.New("broker is quiting")

        // ErrClosingBroker indicates the broker is in the process of closing.
        ErrClosingBroker = errors.New("broker is closing")

        // ErrNoPoolsAvailable indicates no connection pools are available.
        ErrNoPoolsAvailable = errors.New("no connection pools available")
)

// BrokerConfig contains configuration options for a broker.
type BrokerConfig struct {
        // WriteTimeout is the timeout for writing to connections. Default is 5s.
        WriteTimeout time.Duration
        // ReadTimeout is the timeout for reading from connections. Default is 5s.
        ReadTimeout time.Duration
        // QueueSize is the size of the request queue. Default is 1000.
        QueueSize int
}

// DefaultBrokerConfig returns the default broker configuration.
func DefaultBrokerConfig() *BrokerConfig <span class="cov8" title="1">{
        return &amp;BrokerConfig{
                WriteTimeout: 5 * time.Second,
                ReadTimeout:  5 * time.Second,
                QueueSize:    1000,
        }
}</span>

// Broker coordinates sending requests and receiving responses over pooled connections.
type Broker interface {
        Send(*[]byte) ([]byte, error)
        SendContext(context.Context, *[]byte) ([]byte, error)
        Start() error
        Close()
}

// Logger handles structured logging for the broker.
type Logger interface {
        Print(v ...any)                 // Info level
        Printf(format string, v ...any) // Info level formatted
        Infof(format string, v ...any)  // Info level with formatting
        Warnf(format string, v ...any)  // Warning level
        Errorf(format string, v ...any) // Error level
}

// broker implements the Broker interface.
type broker struct {
        mu           sync.Mutex
        connMu       sync.RWMutex
        workers      int
        recvQueue    chan PoolItem
        compool      []Pool
        requestQueue chan *Task
        pending      sync.Map
        activeConns  sync.Map
        //nolint:containedctx // Necessary for task cancellation within broker queue.
        ctx     context.Context
        cancel  context.CancelFunc
        logger  Logger
        rng     *rand.Rand
        wg      sync.WaitGroup
        closing atomic.Bool
        config  *BrokerConfig
}

// NoopLogger provides a default no-op logger.
type NoopLogger struct{}

func (l *NoopLogger) Print(_ ...any)            {<span class="cov8" title="1">}</span>
func (l *NoopLogger) Printf(_ string, _ ...any) {<span class="cov0" title="0">}</span>
func (l *NoopLogger) Infof(_ string, _ ...any)  {<span class="cov8" title="1">}</span>
func (l *NoopLogger) Warnf(_ string, _ ...any)  {<span class="cov0" title="0">}</span>
func (l *NoopLogger) Errorf(_ string, _ ...any) {<span class="cov0" title="0">}</span>

// NewBroker creates a new message broker.
func NewBroker(p []Pool, n int, l Logger, config *BrokerConfig) Broker <span class="cov8" title="1">{
        if l == nil </span><span class="cov8" title="1">{
                l = &amp;NoopLogger{}
        }</span>
        <span class="cov8" title="1">if config == nil </span><span class="cov8" title="1">{
                config = DefaultBrokerConfig()
        }</span>
        <span class="cov8" title="1">rngSource := rand.NewSource(time.Now().UnixNano())
        rng := rand.New(rngSource)
        ctx, cancel := context.WithCancel(context.Background())

        return &amp;broker{
                workers:      n,
                compool:      p,
                recvQueue:    make(chan PoolItem, n),
                requestQueue: make(chan *Task, config.QueueSize),
                ctx:          ctx,
                cancel:       cancel,
                logger:       l,
                rng:          rng,
                config:       config,
        }</span>
}

// Start launches worker goroutines to process requests.
func (b *broker) Start() error <span class="cov8" title="1">{
        eg := &amp;errgroup.Group{}
        b.logger.Infof("Broker starting with %d workers...", b.workers)

        for i := 0; i &lt; b.workers; i++ </span><span class="cov8" title="1">{
                workerID := i
                b.wg.Add(1)
                eg.Go(func() error </span><span class="cov8" title="1">{
                        defer b.wg.Done()
                        err := b.loop(workerID)
                        return err
                }</span>)
        }

        <span class="cov8" title="1">err := eg.Wait()
        if err != nil &amp;&amp; !errors.Is(err, ErrQuit) </span><span class="cov0" title="0">{
                b.logger.Errorf("Broker stopped with error: %v", err)
        }</span> else<span class="cov8" title="1"> {
                b.logger.Infof("Broker stopped gracefully.")
        }</span>

        <span class="cov8" title="1">return err</span>
}

// Send sends a request and waits for the response.
func (b *broker) Send(req *[]byte) ([]byte, error) <span class="cov8" title="1">{
        task := b.newTask(context.Background(), req)

        b.mu.Lock()
        if b.closing.Load() </span><span class="cov0" title="0">{
                b.mu.Unlock()
                return nil, ErrClosingBroker
        }</span>

        <span class="cov8" title="1">b.pending.Store(string(task.taskID), task)

        select </span>{
        case b.requestQueue &lt;- task:<span class="cov8" title="1">
                b.mu.Unlock()</span>
        case &lt;-b.ctx.Done():<span class="cov0" title="0">
                b.mu.Unlock()
                b.failPending(task)
                return nil, ErrClosingBroker</span>
        default:<span class="cov0" title="0">
                b.mu.Unlock()
                b.failPending(task)
                return nil, ErrClosingBroker</span>
        }

        <span class="cov8" title="1">select </span>{
        case resp := &lt;-task.response:<span class="cov8" title="1">
                return resp, nil</span>
        case err := &lt;-task.errCh:<span class="cov8" title="1">
                return nil, err</span>
        }
}

// SendContext sends a request with context support.
func (b *broker) SendContext(ctx context.Context, req *[]byte) ([]byte, error) <span class="cov8" title="1">{
        task := b.newTask(ctx, req)

        b.mu.Lock()
        if b.closing.Load() </span><span class="cov0" title="0">{
                b.mu.Unlock()
                return nil, ErrClosingBroker
        }</span>

        <span class="cov8" title="1">b.pending.Store(string(task.taskID), task)

        select </span>{
        case b.requestQueue &lt;- task:<span class="cov8" title="1">
                b.mu.Unlock()</span>
        case &lt;-b.ctx.Done():<span class="cov0" title="0">
                b.mu.Unlock()
                b.failPending(task)
                return nil, ErrClosingBroker</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                b.mu.Unlock()
                b.failPending(task)
                return nil, ctx.Err()</span>
        default:<span class="cov0" title="0">
                b.mu.Unlock()
                b.failPending(task)
                return nil, ErrClosingBroker</span>
        }

        <span class="cov8" title="1">select </span>{
        case resp := &lt;-task.response:<span class="cov8" title="1">
                return resp, nil</span>
        case err := &lt;-task.errCh:<span class="cov0" title="0">
                return nil, err</span>
        case &lt;-ctx.Done():<span class="cov8" title="1">
                b.failPending(task)
                return nil, ctx.Err()</span>
        }
}

// Close shuts down the broker and associated pools.
func (b *broker) Close() <span class="cov8" title="1">{
        b.mu.Lock()
        if b.closing.Load() </span><span class="cov8" title="1">{
                b.mu.Unlock()
                return
        }</span>
        <span class="cov8" title="1">b.closing.Store(true)
        b.cancel()
        b.mu.Unlock()

        b.connMu.Lock()
        b.activeConns.Range(func(key, value any) bool </span><span class="cov0" title="0">{
                if conn, ok := value.(net.Conn); ok </span><span class="cov0" title="0">{
                        if err := conn.Close(); err != nil </span><span class="cov0" title="0">{
                                if keyStr, ok := key.(string); ok </span><span class="cov0" title="0">{
                                        b.logger.Warnf("Error closing connection for task %s: %v", keyStr, err)
                                }</span>
                        }
                }
                <span class="cov0" title="0">b.activeConns.Delete(key)

                return true</span>
        })
        <span class="cov8" title="1">b.connMu.Unlock()

        done := make(chan struct{})
        go func() </span><span class="cov8" title="1">{
                b.wg.Wait()
                close(done)
        }</span>()

        <span class="cov8" title="1">select </span>{
        case &lt;-done:<span class="cov8" title="1"></span>
        case &lt;-time.After(5 * time.Second):<span class="cov0" title="0">
                b.logger.Warnf("Timeout waiting for workers to finish, forcing close.")</span>
        }

        <span class="cov8" title="1">close(b.requestQueue)

        b.pending.Range(func(key, value any) bool </span><span class="cov0" title="0">{
                task, ok := value.(*Task)
                if !ok </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov0" title="0">select </span>{
                case task.errCh &lt;- ErrClosingBroker:<span class="cov0" title="0"></span>
                default:<span class="cov0" title="0"></span>
                }
                <span class="cov0" title="0">close(task.response)
                close(task.errCh)
                b.pending.Delete(key)

                return true</span>
        })

        <span class="cov8" title="1">for _, p := range b.compool </span><span class="cov8" title="1">{
                p.Close()
        }</span>

        <span class="cov8" title="1">b.logger.Print("Broker closed.")</span>
}

// Internal methods.

func (b *broker) loop(workerID int) error <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-b.ctx.Done():<span class="cov8" title="1">
                        return ErrQuit</span>
                case task, ok := &lt;-b.requestQueue:<span class="cov8" title="1">
                        if !ok </span><span class="cov0" title="0">{
                                return nil
                        }</span>

                        <span class="cov8" title="1">if b.closing.Load() </span><span class="cov0" title="0">{
                                b.trySendError(task, ErrClosingBroker)
                                continue</span>
                        }

                        <span class="cov8" title="1">taskCtx := task.Context()

                        b.connMu.RLock()
                        p := b.pickConnPool()
                        b.connMu.RUnlock()

                        if p == nil </span><span class="cov0" title="0">{
                                b.trySendError(task, ErrNoPoolsAvailable)

                                continue</span>
                        }

                        <span class="cov8" title="1">var wr PoolItem
                        var err error
                        if taskCtx != nil </span><span class="cov8" title="1">{
                                wr, err = p.GetWithContext(taskCtx)
                        }</span> else<span class="cov0" title="0"> {
                                wr, err = p.Get()
                        }</span>

                        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                                if taskCtx != nil &amp;&amp; errors.Is(err, taskCtx.Err()) </span><span class="cov8" title="1">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">b.trySendError(task, fmt.Errorf("failed to get connection: %w", err))

                                continue</span>
                        }

                        <span class="cov8" title="1">err = b.handleConnection(task, wr)
                        if err != nil </span><span class="cov0" title="0">{
                                p.Release(wr)

                                continue</span>
                        }

                        <span class="cov8" title="1">p.Put(wr)</span>
                }
        }
}

func (b *broker) handleConnection(task *Task, wr PoolItem) error <span class="cov8" title="1">{
        netConn, ok := wr.(net.Conn)
        if !ok </span><span class="cov0" title="0">{
                err := errors.New("internal error: pool item is not net.Conn")
                b.trySendError(task, err)
                return err
        }</span>

        <span class="cov8" title="1">b.connMu.Lock()
        b.activeConns.Store(string(task.taskID), netConn)
        b.connMu.Unlock()

        defer func() </span><span class="cov8" title="1">{
                b.connMu.Lock()
                b.activeConns.Delete(string(task.taskID))
                b.connMu.Unlock()
        }</span>()

        <span class="cov8" title="1">cmd := b.addTask(task)

        if b.closing.Load() </span><span class="cov0" title="0">{
                b.trySendError(task, ErrClosingBroker)
                return ErrClosingBroker
        }</span>

        <span class="cov8" title="1">writeDeadline := time.Now().Add(b.config.WriteTimeout)
        if err := netConn.SetWriteDeadline(writeDeadline); err != nil </span><span class="cov0" title="0">{
                b.trySendError(task, fmt.Errorf("setting write deadline: %w", err))
                return err
        }</span>

        <span class="cov8" title="1">if err := Write(netConn, cmd); err != nil </span><span class="cov0" title="0">{
                b.trySendError(task, fmt.Errorf("writing to connection: %w", err))
                return err
        }</span>

        <span class="cov8" title="1">readDeadline := time.Now().Add(b.config.ReadTimeout)
        if err := netConn.SetReadDeadline(readDeadline); err != nil </span><span class="cov0" title="0">{
                b.trySendError(task, fmt.Errorf("setting read deadline: %w", err))
                return err
        }</span>

        <span class="cov8" title="1">taskCtx := task.Context()
        if taskCtx != nil </span><span class="cov8" title="1">{
                done := make(chan struct{})
                var readErr error
                go func() </span><span class="cov8" title="1">{
                        defer close(done)
                        resp, err := Read(netConn)
                        if err != nil </span><span class="cov0" title="0">{
                                readErr = fmt.Errorf("reading from connection: %w", err)
                                b.trySendError(task, readErr)
                                return
                        }</span>
                        <span class="cov8" title="1">b.respondPending(resp)</span>
                }()

                <span class="cov8" title="1">select </span>{
                case &lt;-taskCtx.Done():<span class="cov0" title="0">
                        err := taskCtx.Err()
                        return err</span>
                case &lt;-done:<span class="cov8" title="1">
                        if readErr != nil </span><span class="cov0" title="0">{
                                return readErr
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                resp, err := Read(netConn)
                if err != nil </span><span class="cov0" title="0">{
                        wrappedErr := fmt.Errorf("reading from connection: %w", err)
                        b.trySendError(task, wrappedErr)
                        return wrappedErr
                }</span>
                <span class="cov0" title="0">b.respondPending(resp)</span>
        }

        <span class="cov8" title="1">_ = netConn.SetDeadline(time.Time{})

        return nil</span>
}

func (b *broker) pickConnPool() Pool <span class="cov8" title="1">{
        b.mu.Lock()
        defer b.mu.Unlock()
        if len(b.compool) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return b.activePool()[b.rng.Intn(len(b.compool))]</span>
}

func (b *broker) activePool() []Pool <span class="cov8" title="1">{
        return b.compool
}</span>

func (b *broker) trySendError(task *Task, err error) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{ _ = recover() }</span>()
        <span class="cov8" title="1">select </span>{
        case task.errCh &lt;- err:<span class="cov8" title="1">
                b.failPending(task)</span>
        default:<span class="cov0" title="0"></span>
        }
}

func (b *broker) respondPending(resp []byte) <span class="cov8" title="1">{
        if len(resp) &lt; taskIDSize </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">taskID := string(resp[:taskIDSize])

        if value, ok := b.pending.Load(taskID); ok </span><span class="cov8" title="1">{
                task, castOK := value.(*Task)
                if !castOK </span><span class="cov0" title="0">{
                        b.pending.Delete(taskID)
                        return
                }</span>

                <span class="cov8" title="1">sent := false
                func() </span><span class="cov8" title="1">{
                        defer func() </span><span class="cov8" title="1">{ _ = recover() }</span>()
                        <span class="cov8" title="1">select </span>{
                        case task.response &lt;- resp[taskIDSize:]:<span class="cov8" title="1">
                                sent = true</span>
                        default:<span class="cov0" title="0"></span>
                        }
                }()

                <span class="cov8" title="1">if sent </span><span class="cov8" title="1">{
                        b.pending.Delete(taskID)
                }</span>
        }
}

func (b *broker) failPending(task *Task) <span class="cov8" title="1">{
        b.pending.Delete(string(task.taskID))
        func() </span><span class="cov8" title="1">{
                defer func() </span><span class="cov8" title="1">{ _ = recover() }</span>()
                <span class="cov8" title="1">close(task.response)
                close(task.errCh)</span>
        }()
}

func (b *broker) newTask(ctx context.Context, r *[]byte) *Task <span class="cov8" title="1">{
        taskIDBytes := make([]byte, taskIDSize)
        b.mu.Lock()
        _, _ = b.rng.Read(taskIDBytes)
        b.mu.Unlock()

        return &amp;Task{
                ctx:      ctx,
                taskID:   taskIDBytes,
                request:  r,
                response: make(chan []byte, 1),
                errCh:    make(chan error, 1),
                created:  time.Now(),
        }
}</span>

func (b *broker) addTask(task *Task) []byte <span class="cov8" title="1">{
        cmd := make([]byte, taskIDSize+len(*task.request))
        copy(cmd[:taskIDSize], task.taskID)
        copy(cmd[taskIDSize:], *task.request)

        return cmd
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package anet provides network communication components.
package anet

import (
        "sync"
)

// maxBufferSize is the maximum size of buffers that will be pooled.
// Larger buffers will be allocated but not pooled to prevent memory bloat.
const maxBufferSize = 64 * 1024 // 64KB

// bufferPool manages a set of sync.Pool instances for different buffer sizes.
// This helps reduce memory allocations and GC pressure by reusing buffers.
type bufferPool struct {
        pools []*sync.Pool // Array of pools for different size classes
}

// Global buffer pool instance used by the message framing utilities.
var globalBufferPool = newBufferPool()

// newBufferPool creates a new buffer pool with pre-allocated sync.Pool instances
// for common buffer sizes. This improves performance by reducing allocations
// for frequently used message sizes.
func newBufferPool() *bufferPool <span class="cov8" title="1">{
        bp := &amp;bufferPool{
                pools: make([]*sync.Pool, 32), // Pool sizes from 32B to 64KB
        }

        for i := range bp.pools </span><span class="cov8" title="1">{
                size := 32 &lt;&lt; uint(i) // 32, 64, 128, ..., 64KB
                if size &gt; maxBufferSize </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">bp.pools[i] = &amp;sync.Pool{
                        New: func() interface{} </span><span class="cov8" title="1">{
                                return make([]byte, size)
                        }</span>,
                }
        }

        <span class="cov8" title="1">return bp</span>
}

// getBuffer retrieves a buffer from the pool that is at least size bytes.
// If no suitable buffer exists in the pool, a new one will be allocated.
// The returned buffer may be larger than requested but will be at least size bytes.
func (bp *bufferPool) getBuffer(size int) []byte <span class="cov8" title="1">{
        if size &gt; maxBufferSize </span><span class="cov0" title="0">{
                return make([]byte, size)
        }</span>

        // Find the smallest pool that fits the size
        <span class="cov8" title="1">poolIdx := 0
        poolSize := 32
        for poolSize &lt; size </span><span class="cov0" title="0">{
                poolSize *= 2
                poolIdx++
        }</span>

        <span class="cov8" title="1">return bp.pools[poolIdx].Get().([]byte)</span>
}

// putBuffer returns a buffer to the pool for future reuse.
// Buffers larger than maxBufferSize are not pooled to prevent memory bloat.
// The buffer should not be accessed after being returned to the pool.
func (bp *bufferPool) putBuffer(buf []byte) <span class="cov8" title="1">{
        if len(buf) &gt; maxBufferSize </span><span class="cov0" title="0">{
                return // Don't pool large buffers
        }</span>

        // Find the correct pool
        <span class="cov8" title="1">poolIdx := 0
        poolSize := 32
        for poolSize &lt; len(buf) </span><span class="cov0" title="0">{
                poolSize *= 2
                poolIdx++
        }</span>

        <span class="cov8" title="1">bp.pools[poolIdx].Put(buf)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package main provides an example of using the anet library.
package main

import (
        "context"
        "encoding/binary"
        "errors"
        "fmt"
        "io"
        "log"
        "net"
        "os"
        "sync"
        "time"

        "github.com/andrei-cloud/anet"
)

// taskIDSize is the size in bytes of the task ID header used by the broker.
const taskIDSize = 4

// loggerWrapper adapts the standard log.Logger to satisfy anet.Logger interface.
type loggerWrapper struct {
        *log.Logger
}

// Logger interface implementation.
func (lw *loggerWrapper) Printf(format string, v ...any) <span class="cov0" title="0">{
        lw.Logger.Printf(format, v...)
}</span>

func (lw *loggerWrapper) Print(v ...any) <span class="cov0" title="0">{
        lw.Logger.Print(v...)
}</span>

func (lw *loggerWrapper) Debugf(format string, v ...any) <span class="cov0" title="0">{
        lw.Printf("[DEBUG] "+format, v...)
}</span>

func (lw *loggerWrapper) Infof(format string, v ...any) <span class="cov0" title="0">{
        lw.Printf(format, v...)
}</span>

func (lw *loggerWrapper) Warnf(format string, v ...any) <span class="cov0" title="0">{
        lw.Printf("[WARN] "+format, v...)
}</span>

func (lw *loggerWrapper) Errorf(format string, v ...any) <span class="cov0" title="0">{
        lw.Printf("[ERROR] "+format, v...)
}</span>

// startEchoServer creates a TCP server that demonstrates the message framing protocol.
// It reads messages with a length header and task ID, then echoes them back.
func startEchoServer(addr string) error <span class="cov0" title="0">{
        listener, err := net.Listen("tcp", addr)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start echo server: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := listener.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error closing listener: %v", err)
                }</span>
        }()
        <span class="cov0" title="0">log.Printf("Echo server listening on %s", addr)

        for </span><span class="cov0" title="0">{
                conn, err := listener.Accept()
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Server accept error: %v", err)
                        continue</span>
                }
                <span class="cov0" title="0">go handleEchoConnection(conn)</span>
        }
}

// handleEchoConnection processes a single client connection using the message framing protocol.
func handleEchoConnection(conn net.Conn) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if err := conn.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error closing connection: %v", err)
                }</span>
        }()
        <span class="cov0" title="0">log.Printf("Server accepted connection from %s", conn.RemoteAddr())

        for </span><span class="cov0" title="0">{
                // Read length header (uint16).
                lenHeader := make([]byte, 2)
                if _, err := io.ReadFull(conn, lenHeader); err != nil </span><span class="cov0" title="0">{
                        if err != io.EOF </span><span class="cov0" title="0">{
                                log.Printf("Server read length error: %v", err)
                        }</span>

                        <span class="cov0" title="0">return</span>
                }
                <span class="cov0" title="0">msgLen := binary.BigEndian.Uint16(lenHeader)

                // Read message body (including Task ID).
                msg := make([]byte, msgLen)
                if _, err := io.ReadFull(conn, msg); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Server read body error: %v", err)
                        return
                }</span>

                <span class="cov0" title="0">log.Printf(
                        "Server received %d bytes: TaskID=%x Data=%s",
                        len(msg),
                        msg[:taskIDSize],
                        string(msg[taskIDSize:]),
                )

                // Echo back (write length header + original message).
                if err := anet.Write(conn, msg); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Server write error: %v", err)
                        return
                }</span>
                <span class="cov0" title="0">log.Printf("Server echoed %d bytes", len(msg))</span>
        }
}

// tcpConnectionFactory creates new TCP connections for the connection pool.
// It implements proper timeouts and TCP keepalive settings.
func tcpConnectionFactory(addr string) (anet.PoolItem, error) <span class="cov0" title="0">{
        conn, err := net.DialTimeout("tcp", addr, 5*time.Second)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to dial %s: %w", addr, err)
        }</span>

        <span class="cov0" title="0">poolItem, ok := conn.(anet.PoolItem)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("failed to assert net.Conn as anet.PoolItem")
        }</span>

        <span class="cov0" title="0">return poolItem, nil</span>
}

func main() <span class="cov0" title="0">{
        // Configure logging with microsecond precision.
        log.SetFlags(log.LstdFlags | log.Lmicroseconds)

        // Start echo server.
        serverAddr := "localhost:3000"
        go func() </span><span class="cov0" title="0">{
                if err := startEchoServer(serverAddr); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Error starting echo server: %v", err)
                }</span>
        }()
        <span class="cov0" title="0">time.Sleep(100 * time.Millisecond) // Give server time to start.

        // Initialize connection pool.
        poolCap := uint32(5)
        pools := anet.NewPoolList(poolCap, tcpConnectionFactory, []string{serverAddr}, nil)

        // Configure and create broker.
        numWorkers := 3
        logger := &amp;loggerWrapper{
                Logger: log.New(os.Stdout, "BROKER: ", log.LstdFlags|log.Lmicroseconds),
        }
        broker := anet.NewBroker(pools, numWorkers, logger, nil)

        // Start broker workers and ensure cleanup.
        go func() </span><span class="cov0" title="0">{
                if err := broker.Start(); err != nil &amp;&amp; err != anet.ErrQuit </span><span class="cov0" title="0">{
                        log.Fatalf("Broker failed: %v", err)
                }</span>
        }()
        <span class="cov0" title="0">defer broker.Close()

        // Send concurrent requests.
        requests := []string{"hello", "world", "anet test", "concurrent", "request"}
        var wg sync.WaitGroup

        for _, reqStr := range requests </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(requestPayload string) </span><span class="cov0" title="0">{
                        defer wg.Done()

                        reqData := []byte(requestPayload)
                        log.Printf("Client sending: %s", requestPayload)

                        ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
                        defer cancel()

                        respData, err := broker.SendContext(ctx, &amp;reqData)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Client error sending '%s': %v", requestPayload, err)
                        }</span> else<span class="cov0" title="0"> {
                                log.Printf("Client received response for '%s': %s",
                                        requestPayload, string(respData))
                        }</span>
                }(reqStr)
        }

        <span class="cov0" title="0">log.Println("Client launched all requests.")
        wg.Wait()
        log.Println("Client finished processing all responses.")

        time.Sleep(200 * time.Millisecond)</span> // Allow logs to flush.
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package anet

import (
        "context"
        "errors"
        "fmt"
        "net"
        "os"
        "sync"
        "sync/atomic"
        "time"
)

// ErrClosing indicates the pool is shutting down.
var ErrClosing = errors.New("pool is closing")

// PoolConfig contains configuration options for a connection pool.
type PoolConfig struct {
        // DialTimeout is the timeout for creating new connections. Default is 5s.
        DialTimeout time.Duration
        // IdleTimeout is how long a connection can remain idle before being closed. Default is 60s.
        IdleTimeout time.Duration
        // ValidationInterval is how often to validate idle connections. Default is 30s.
        ValidationInterval time.Duration
        // KeepAliveInterval is the interval for TCP keepalive. Default is 30s.
        KeepAliveInterval time.Duration
}

// DefaultPoolConfig returns the default configuration.
func DefaultPoolConfig() *PoolConfig <span class="cov8" title="1">{
        return &amp;PoolConfig{
                DialTimeout:        5 * time.Second,
                IdleTimeout:        60 * time.Second,
                ValidationInterval: 30 * time.Second,
                KeepAliveInterval:  30 * time.Second,
        }
}</span>

// Pool manages a collection of reusable connections.
type Pool interface {
        Get() (PoolItem, error)
        GetWithContext(context.Context) (PoolItem, error)
        Release(PoolItem)
        Put(PoolItem)
        Len() int
        Cap() int
        Close()
}

// PoolItem represents a closeable resource managed by the pool.
type PoolItem interface {
        Close() error
}

// Factory creates new pool items.
type Factory func(string) (PoolItem, error)

// pool implements the Pool interface.
type pool struct {
        mu          sync.RWMutex
        addr        string
        capacity    uint32
        count       atomic.Uint32
        queue       chan PoolItem
        factoryFunc Factory
        closing     atomic.Bool
        logger      *os.File
        config      *PoolConfig
        stopChan    chan struct{}
}

// NewPoolList creates a list of Pool interfaces from a slice of addresses.
func NewPoolList(poolCap uint32, f Factory, addrs []string, config *PoolConfig) []Pool <span class="cov8" title="1">{
        if config == nil </span><span class="cov8" title="1">{
                config = DefaultPoolConfig()
        }</span>
        <span class="cov8" title="1">pools := make([]Pool, 0, len(addrs))
        for _, addr := range addrs </span><span class="cov8" title="1">{
                p := NewPool(poolCap, f, addr, config)
                pools = append(pools, p)
        }</span>

        <span class="cov8" title="1">return pools</span>
}

// NewPool creates a new connection pool.
func NewPool(poolCap uint32, f Factory, addr string, config *PoolConfig) Pool <span class="cov8" title="1">{
        if config == nil </span><span class="cov8" title="1">{
                config = DefaultPoolConfig()
        }</span>
        <span class="cov8" title="1">p := &amp;pool{
                addr:        addr,
                capacity:    poolCap,
                queue:       make(chan PoolItem, poolCap),
                factoryFunc: f,
                logger:      os.Stderr,
                config:      config,
                stopChan:    make(chan struct{}),
        }
        p.closing.Store(false)

        // Start background validation if interval is set
        if p.config.ValidationInterval &gt; 0 </span><span class="cov8" title="1">{
                go p.validateIdleConnections()
        }</span>

        <span class="cov8" title="1">return p</span>
}

// validateConnection performs basic connection health check.
func (p *pool) validateConnection(item PoolItem) bool <span class="cov8" title="1">{
        if item == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">if conn, ok := item.(net.Conn); ok </span><span class="cov8" title="1">{
                if conn == nil </span><span class="cov0" title="0">{
                        return false
                }</span>

                // Check if connection has been idle too long
                <span class="cov8" title="1">if tcpConn, ok := conn.(*net.TCPConn); ok </span><span class="cov8" title="1">{
                        if err := tcpConn.SetKeepAlive(true); err != nil </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov8" title="1">if err := tcpConn.SetKeepAlivePeriod(p.config.KeepAliveInterval); err != nil </span><span class="cov0" title="0">{
                                return false
                        }</span>

                        // Set a short read deadline to check if the connection is still alive
                        <span class="cov8" title="1">if err := conn.SetReadDeadline(time.Now().Add(100 * time.Millisecond)); err != nil </span><span class="cov0" title="0">{
                                return false
                        }</span>

                        // Try to read 0 bytes to check connection status
                        <span class="cov8" title="1">if _, err := conn.Read(make([]byte, 0)); err != nil </span><span class="cov0" title="0">{
                                if !os.IsTimeout(err) </span><span class="cov0" title="0">{ // timeout is expected and means connection is still good
                                        return false
                                }</span>
                        }

                        // Reset the deadline
                        <span class="cov8" title="1">if err := conn.SetReadDeadline(time.Time{}); err != nil </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
        }

        <span class="cov8" title="1">return true</span>
}

// validateIdleConnections periodically validates idle connections in the pool.
func (p *pool) validateIdleConnections() <span class="cov8" title="1">{
        ticker := time.NewTicker(p.config.ValidationInterval)
        defer ticker.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-p.stopChan:<span class="cov8" title="1">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        p.mu.Lock()
                        if p.closing.Load() </span><span class="cov0" title="0">{
                                p.mu.Unlock()
                                return
                        }</span>
                        // Copy current items to a slice for validation
                        <span class="cov0" title="0">items := make([]PoolItem, 0, len(p.queue))
                        for len(p.queue) &gt; 0 </span><span class="cov0" title="0">{
                                if item := &lt;-p.queue; item != nil </span><span class="cov0" title="0">{
                                        items = append(items, item)
                                }</span>
                        }
                        <span class="cov0" title="0">p.mu.Unlock()

                        // Validate each connection
                        for _, item := range items </span><span class="cov0" title="0">{
                                if p.validateConnection(item) </span><span class="cov0" title="0">{
                                        p.Put(item)
                                }</span> else<span class="cov0" title="0"> {
                                        p.Release(item)
                                }</span>
                        }
                }
        }
}

// Get retrieves an item from the pool.
func (p *pool) Get() (PoolItem, error) <span class="cov8" title="1">{
        if p.closing.Load() </span><span class="cov8" title="1">{
                return nil, ErrClosing
        }</span>

        // Try to get an existing connection from the queue
        <span class="cov8" title="1">select </span>{
        case item := &lt;-p.queue:<span class="cov0" title="0">
                if item == nil </span><span class="cov0" title="0">{
                        return nil, ErrClosing
                }</span>

                <span class="cov0" title="0">if p.validateConnection(item) </span><span class="cov0" title="0">{
                        return item, nil
                }</span>

                <span class="cov0" title="0">p.Release(item)</span>
        default:<span class="cov8" title="1"></span>
        }

        // Try to create a new connection if under capacity
        <span class="cov8" title="1">current := p.count.Load()
        if current &lt; p.capacity </span><span class="cov8" title="1">{
                if p.count.CompareAndSwap(current, current+1) </span><span class="cov8" title="1">{
                        item, err := p.factoryFunc(p.addr)
                        if err != nil </span><span class="cov8" title="1">{
                                p.count.Add(^uint32(0))

                                return nil, err
                        }</span>

                        <span class="cov8" title="1">return item, nil</span>
                }
        }

        // Wait for a connection to become available
        <span class="cov0" title="0">item := &lt;-p.queue
        if item == nil </span><span class="cov0" title="0">{
                return nil, ErrClosing
        }</span>

        <span class="cov0" title="0">if p.validateConnection(item) </span><span class="cov0" title="0">{
                return item, nil
        }</span>

        <span class="cov0" title="0">p.Release(item)

        return p.Get()</span> // Recursively try again if connection is invalid
}

// GetWithContext retrieves an item with context awareness.
func (p *pool) GetWithContext(ctx context.Context) (PoolItem, error) <span class="cov8" title="1">{
        if p.closing.Load() </span><span class="cov0" title="0">{
                return nil, ErrClosing
        }</span>

        // Fast path: try to get an existing connection
        <span class="cov8" title="1">select </span>{
        case item := &lt;-p.queue:<span class="cov8" title="1">
                if item == nil </span><span class="cov0" title="0">{
                        return nil, ErrClosing
                }</span>
                <span class="cov8" title="1">if p.validateConnection(item) </span><span class="cov8" title="1">{
                        return item, nil
                }</span>
                <span class="cov0" title="0">p.Release(item)</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return nil, ctx.Err()</span>
        default:<span class="cov8" title="1"></span>
        }

        // Try to create a new connection if under capacity
        <span class="cov8" title="1">current := p.count.Load()
        if current &lt; p.capacity </span><span class="cov8" title="1">{
                if p.count.CompareAndSwap(current, current+1) </span><span class="cov8" title="1">{
                        item, err := p.factoryFunc(p.addr)
                        if err != nil </span><span class="cov8" title="1">{
                                p.count.Add(^uint32(0))

                                return nil, err
                        }</span>

                        <span class="cov8" title="1">return item, nil</span>
                }
        }

        // Wait for an available connection or context cancellation
        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                select </span>{
                case item := &lt;-p.queue:<span class="cov0" title="0">
                        if item == nil </span><span class="cov0" title="0">{
                                return nil, ErrClosing
                        }</span>
                        <span class="cov0" title="0">if p.validateConnection(item) </span><span class="cov0" title="0">{
                                return item, nil
                        }</span>
                        <span class="cov0" title="0">p.Release(item)</span>
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return nil, ctx.Err()</span>
                }
        }
}

// Put returns an item to the pool.
func (p *pool) Put(item PoolItem) <span class="cov8" title="1">{
        if item == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">if p.closing.Load() </span><span class="cov8" title="1">{
                p.Release(item)

                return
        }</span>

        <span class="cov8" title="1">if !p.validateConnection(item) </span><span class="cov0" title="0">{
                p.Release(item)

                return
        }</span>

        <span class="cov8" title="1">select </span>{
        case p.queue &lt;- item:<span class="cov8" title="1"></span>
        default:<span class="cov0" title="0">
                p.Release(item)</span>
        }
}

// Release closes an item and decrements pool count.
func (p *pool) Release(item PoolItem) <span class="cov8" title="1">{
        if item != nil </span><span class="cov8" title="1">{
                p.count.Add(^uint32(0))
                if err := item.Close(); err != nil </span><span class="cov0" title="0">{
                        if p.logger != nil </span><span class="cov0" title="0">{
                                if _, err := fmt.Fprintf(p.logger, "Error closing pool item: %v\n", err); err != nil </span><span class="cov0" title="0">{
                                        _, _ = fmt.Fprintf(os.Stderr, "Error writing to logger: %v\n", err)
                                }</span>
                        }
                }
        }
}

// Close closes the pool and all its items.
func (p *pool) Close() <span class="cov8" title="1">{
        // Fast check to avoid lock if already closing
        if p.closing.Load() </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">p.mu.Lock()
        // Double check after acquiring lock
        if p.closing.Load() </span><span class="cov0" title="0">{
                p.mu.Unlock()

                return
        }</span>
        <span class="cov8" title="1">p.closing.Store(true)
        close(p.queue)
        close(p.stopChan)

        // Collect items to close outside the lock
        itemsToClose := make([]PoolItem, 0, cap(p.queue))
        for item := range p.queue </span><span class="cov8" title="1">{
                if item != nil </span><span class="cov8" title="1">{
                        itemsToClose = append(itemsToClose, item)
                }</span>
        }
        <span class="cov8" title="1">p.mu.Unlock()

        // Release items outside the lock
        for _, item := range itemsToClose </span><span class="cov8" title="1">{
                p.Release(item)
        }</span>
}

// Len returns the current number of items in the pool.
func (p *pool) Len() int <span class="cov8" title="1">{
        return int(p.count.Load())
}</span>

// Cap returns the capacity of the pool.
func (p *pool) Cap() int <span class="cov8" title="1">{
        return int(p.capacity)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package anet

import (
        "context"
        "encoding/hex"
        "sync"
        "time"
)

// Constants for task management.
const (
        // taskIDSize is the size in bytes of the task ID header.
        // This must be consistent between broker and server implementations.
        taskIDSize = 4
)

// Task represents a single request/response operation managed by the broker.
// Each task has a unique ID that is prepended to the request message and
// must be included at the start of the response for proper correlation.
type Task struct {
        //nolint:containedctx // Necessary for task cancellation within broker queue.
        ctx       context.Context // Context for cancellation and timeouts
        taskID    []byte          // Unique identifier for request/response correlation
        request   *[]byte         // Request payload to be sent
        response  chan []byte     // Channel for receiving the response
        errCh     chan error      // Channel for receiving errors
        created   time.Time       // Creation timestamp for monitoring
        closeOnce sync.Once       // Ensures cleanup runs exactly once
}

// Context returns the task's context, which can be used for cancellation
// and timeout control. The context is typically created with a timeout
// when using SendContext.
func (t *Task) Context() context.Context <span class="cov8" title="1">{
        return t.ctx
}</span>

// ID returns the task's unique ID as a hexadecimal string.
// This is useful for logging and debugging request/response flows.
func (t *Task) ID() string <span class="cov0" title="0">{
        return hex.EncodeToString(t.taskID)
}</span>

// Created returns the task creation time.
// This can be used to monitor request latency and detect stale tasks.
func (t *Task) Created() time.Time <span class="cov0" title="0">{
        return t.created
}</span>

// Request returns the request payload.
// The broker will prepend the task ID to this payload before sending.
func (t *Task) Request() *[]byte <span class="cov0" title="0">{
        return t.request
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package anet

import (
        "encoding/binary"
        "errors"
        "fmt"
        "io"
)

// Message framing constants.
const (
        // LENGTHSIZE defines the size of the length header in bytes.
        // The length header is a big-endian uint16 value.
        LENGTHSIZE = 2
)

// Common framing errors.
var (
        // ErrInvalidMsgLength indicates that a message length header is invalid.
        ErrInvalidMsgLength = errors.New("invalid message length")

        // ErrMaxLenExceeded indicates the message length exceeds the maximum allowed.
        // This is determined by the maximum value that can be stored in LENGTHSIZE bytes.
        ErrMaxLenExceeded = errors.New("maximum message length exceeded")
)

// Write sends data over a connection using the message framing protocol.
// It prepends a big-endian length header of LENGTHSIZE bytes to the data.
// The maximum message size is determined by LENGTHSIZE (65535 bytes for uint16).
//
// The complete frame format is:
//
//        [length header (2 bytes)][payload (length bytes)]
//
// Returns ErrMaxLenExceeded if the message is too large for the length header.
func Write(w io.Writer, in []byte) error <span class="cov8" title="1">{
        // Calculate maximum allowed length based on header size
        maxLen := uint64(1&lt;&lt;(8*LENGTHSIZE)) - 1
        if uint64(len(in)) &gt; maxLen </span><span class="cov0" title="0">{
                return ErrMaxLenExceeded
        }</span>

        // Get a buffer from the pool for the header
        <span class="cov8" title="1">headerBuf := globalBufferPool.getBuffer(LENGTHSIZE)
        defer globalBufferPool.putBuffer(headerBuf)

        // Write length as big-endian value
        switch LENGTHSIZE </span>{
        case 2:<span class="cov8" title="1">
                binary.BigEndian.PutUint16(headerBuf, uint16(len(in)))</span>
        case 4:<span class="cov0" title="0">
                binary.BigEndian.PutUint32(headerBuf, uint32(len(in)))</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported header size: %d", LENGTHSIZE)</span>
        }

        // Write the header
        <span class="cov8" title="1">if _, err := w.Write(headerBuf[:LENGTHSIZE]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Write the payload
        <span class="cov8" title="1">if _, err := w.Write(in); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Read receives data from a connection using the message framing protocol.
// It first reads a big-endian length header of LENGTHSIZE bytes, then reads
// the specified number of payload bytes.
//
// The complete frame format is:
//
//        [length header (2 bytes)][payload (length bytes)]
//
// Returns:
//   - The payload data
//   - io.EOF if the connection was closed cleanly
//   - Other errors for network or protocol issues
func Read(r io.Reader) ([]byte, error) <span class="cov8" title="1">{
        // Get a buffer from the pool for the header
        headerBuf := globalBufferPool.getBuffer(LENGTHSIZE)
        defer globalBufferPool.putBuffer(headerBuf)

        // Read the length header
        if _, err := io.ReadFull(r, headerBuf[:LENGTHSIZE]); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Parse the length value
        <span class="cov8" title="1">var length uint64
        switch LENGTHSIZE </span>{
        case 2:<span class="cov8" title="1">
                length = uint64(binary.BigEndian.Uint16(headerBuf))</span>
        case 4:<span class="cov0" title="0">
                length = uint64(binary.BigEndian.Uint32(headerBuf))</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported header size: %d", LENGTHSIZE)</span>
        }

        // Get a buffer from the pool for the message
        <span class="cov8" title="1">message := globalBufferPool.getBuffer(int(length))
        defer globalBufferPool.putBuffer(message)

        // Read the payload
        if _, err := io.ReadFull(r, message[:length]); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create a new buffer containing just the payload data
        // This is necessary as the pooled buffer will be reused
        <span class="cov8" title="1">result := make([]byte, length)
        copy(result, message[:length])

        return result, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
